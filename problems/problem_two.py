"""
Problem 2

Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million,
find the sum of the even-valued terms.

---
NOTE: by starting with 1 and 2, I am doing what fibonacci himself did. Anyone starting from 0 and 1 or 1 and 1 can
go do their own implementation
"""

from functools import lru_cache
import math

from utils.decorators import timed

from numba import jit, int32, float64


def get_fibonacci_at_position_recursive(position: int):
    """
    this function recursively calculate the fibonacci number at a given position

    >>> get_fibonacci_at_position_recursive(10)
    89
    >>> get_fibonacci_at_position_recursive(11)
    144
    >>> get_fibonacci_at_position_recursive(12)
    233

    :param position: an integer representing the position in the sequence of fibonacci numbers we want
    :return: the fibonacci number at the given position
    """
    if position < 3:
        return position
    return get_fibonacci_at_position_recursive(position - 2) + get_fibonacci_at_position_recursive(position - 1)


# the maxsize is 3 because
@lru_cache(maxsize=3, typed=False)
def get_fibonacci_at_position_cached(position: int):
    """
    get the fibonacci number at a position but using an LRU cache to prevent the need for actual recursive calculation

    >>> get_fibonacci_at_position_cached(10)
    89
    >>> get_fibonacci_at_position_cached(11)
    144
    >>> get_fibonacci_at_position_cached(12)
    233

    :param position: an integer representing the position in the sequence of fibonacci numbers we want
    :return: the fibonacci number at the given position
    """
    if position < 3:
        return position
    return get_fibonacci_at_position_cached(position - 2) + get_fibonacci_at_position_cached(position - 1)


def get_fibonacci_at_position_formula_python(position: int):
    """
    fibonacci numbers can be directly calculated thanks to good mathematicians
    direct calculation taken from https://stackoverflow.com/questions/50622088/fibonacci-direct-calculation-formula

    >>> get_fibonacci_at_position_formula_python(10)
    89
    >>> get_fibonacci_at_position_formula_python(11)
    144
    >>> get_fibonacci_at_position_formula_python(12)
    233

    :param position: an integer representing the position in the sequence of fibonacci numbers we want
    :return: the fibonacci number at the given position
    """
    phi = (1 + math.sqrt(5)) / 2
    psi = (1 - math.sqrt(5)) / 2
    return int((phi ** (position + 1) - psi ** (position + 1)) / math.sqrt(5))


@jit(float64(float64, int32))
def exponentiation(base: float, power: int):
    """
    A function to compile exponentiation


    """
    return base ** power


# you have to specify the type float64 here to get the compiled code to have enough precision to not round down
@jit(int32(float64))
def get_fibonacci_at_position_formula_numba_compiled(position: int):
    """
    fibonacci numbers can be directly calculated thanks to good mathematicians
    direct calculation taken from https://stackoverflow.com/questions/50622088/fibonacci-direct-calculation-formula

    >>> get_fibonacci_at_position_formula_numba_compiled(10)
    89
    >>> get_fibonacci_at_position_formula_numba_compiled(11)
    144
    >>> get_fibonacci_at_position_formula_numba_compiled(12)
    233

    :param position: an integer representing the position in the sequence of fibonacci numbers we want
    :return: the fibonacci number at the given position
    """
    # can possibly clean this up but I'm ok with it for now
    phi = (1 + math.sqrt(5)) / 2
    psi = (1 - math.sqrt(5)) / 2
    return round((exponentiation(phi, position + 1) - exponentiation(psi, position + 1)) / math.sqrt(5))


@timed
def fibonacci_handler(func):
    """
    This function take a function reference and serves as standardized way to call the function using a given
    set of arguments for an apples-to-apples comparison

    :param func: a reference to a function
    :return: None
    """
    fibonacci_position = 1
    fibonacci_result = 1
    four_million = 4000000
    stop = four_million
    sum_of_evens = 0
    while fibonacci_result < stop:
        if fibonacci_result % 2 == 0:
            sum_of_evens += fibonacci_result
        fibonacci_position += 1
        fibonacci_result = func(fibonacci_position)
    print(sum_of_evens)


def main():
    """
    The main just sets up references to my various fibonacci implementations and passes them to the handler to compare
    their performance against each other. An example run on my i5 laptop looks like

    4613732
    took [2.12574970s] fibonacci_handler(<function get_fibonacci_at_position_recursive at 0x0000028094BEC1E0>) -> None
    4613732
    took [0.00003230s] fibonacci_handler(<functools._lru_cache_wrapper object at 0x000002809526D780>) -> None
    4613732
    took [0.00003330s] fibonacci_handler(<function get_fibonacci_at_position_formula at 0x00000280953A32F0>) -> None

    One interesting thing to note is that the LRU cache performs slightly better than the direct calculation. This holds
    true all the way to numbers above the size of maxint where we'd need to use a special math library to represent the
    values in order to produce the correct result. My hypothesis for such a thing is that the exponentiation of phi and
    psi is slower than simple addition and subtraction that the LRU cache implementation requires

    :return: None
    """
    fibonacci_functions = [get_fibonacci_at_position_recursive,
                           get_fibonacci_at_position_cached,
                           get_fibonacci_at_position_formula_python,
                           get_fibonacci_at_position_formula_numba_compiled]
    for func in fibonacci_functions:
        fibonacci_handler(func)


if __name__ == '__main__':
    import doctest
    doctest.testmod(optionflags=doctest.ELLIPSIS)

    main()
